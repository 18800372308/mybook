## Coredump 调试

gdb </usr/vtm/bin/dpid>  <coredump_file>
常用命令
bt  查看堆栈信息


##C++ 常用关键字

virtual  用来修饰函数就是虚拟函数。也可以声明一个纯虚函数。
     
const   用来标记变量值不可改变，在修饰指针变量时，有两种情况：1 常量指针  指针指向的内容是常量，不能通过指针变量去修改内存中的值。2. 指针常量指针变量本身是常量，指针变量不可修改，可修改*p 指向指向的指针内容。
const 常用修饰函数 指针或者引用形参，防止函数内修改参数对象。同时解决构造临时对象的问题，对一个临时对象没有作用。当用来修饰成员函数时，该成员函数不能修改类中成员变量。
inline  内敛函数。编译器会在调用内敛函数的地方展开，没有函数压栈的开销，提升程序运行效率。缺点增加函数二进制文件大小，以空间换时间。若内敛函数包含循环递归等函数，编译器可能会忽略内敛。

extern  声明外部全局变量
static  声明变量和C++类的静态函数，static 一个作用是信息屏蔽，函数或变量只在该文件中被使用。static 声明局部变量（静态局部变量），会在函数调用结束后保留原值。


explicit 用来修饰C++类的构造函数，若类只有一个参数的构造函数，C++允许一种特殊的声明类变量的方法，编译器编译时自动进行类型转换，添加该关键字则禁止这种自动转换。

export
typedef
friend
register

malloc & free   C和C++ 在动态堆内存申请和释放
new  & delete   C++ 堆内存申请和释放
sizeof   计算变量等对象的内存大小，以字节为单位。

##C++ 宏定义

保证函数声明的唯一性
#ifndef XXX
#define XXX
定义函数声明
#endif

##C++ 重载与覆盖

重载的几个函数必须在同一个类中；
覆盖的函数必须在有继承关系的不同的类中

覆盖的几个函数必须要求函数名、参数、返回值都相同；
重载的函数必须函数名相同，参数不同。参数不同的目的就是为了在函数调用的时候编译器能够通过参数来判断程序是在调用的哪个函数。这也就很自然地解释了为什么函数不能通过返回值不同来重载，因为程序在调用函数时很有可能不关心返回值，编译器就无法从代码中看出程序在调用的是哪个函数了。

覆盖的函数前必须加关键字Virtual；
重载和Virtual没有任何瓜葛，加不加都不影响重载的运作。

##C++类间继承关系
子类和父类

public 成员函数被继承
父类构造函数 无参
子类构造函数 
子类初始化时会默认构造函数或者执行父类声明构造函数。

父类构造函数 有参
子类构造函数 
子类初始化需要在构造函数内显示调用父类构造函数。

C++ 规定析构函数无参 无返回值

子类在析构时 首先调用父类的析构函数，然后父类析构函数。
虚拟析构函数与非虚拟析构函数 当基类的指针指向派生类的对象时，delete基类指针时，如果基类的析构函数不是虚拟的，只会调用基类的析构函数，不会调用派生类的析构函数。

C++ 多态性

只会发生在基类指针指向派生类时才生效。



